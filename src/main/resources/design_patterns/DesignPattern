Singleton design pattern is also used in other design patterns like Abstract Factory, Builder, Prototype, Facade etc.

Java Message Service (JMS) uses Mediator pattern along with Observer pattern to allow applications to subscribe and publish data to other applications.

The decorator pattern takes advantage of Composition to provide new features without modifying the original class.

The state pattern is used to do something specific depending upon state while Strategy allows you to switch between algorithms without changing the code which uses it

The Decorator adds additional functionality without touching the class, Proxy provides access control and Adapter is used to make two incompatible interfaces work together. 
*********************************************
Factory : We dont Expose the creational logic, refer the standard interface to create perticular object.
Vertual COnstructor
**********
How do I restrict object creation not more than 3 in Java class?
We can restrict the creation of Object for a particular class by little modification in Singleton design
******************
Nexus:
Nexus is a repository manager that stores “artifacts”, which allows you to proxy collect and manage your dependencies, making it easy to distribute your software.
When talking about “artifacts”, we mean external libraries like, for example, JARs files for Java libraries and packages for Node. This way, we can have access to multiple external libraries and different versions of them.

GIT qustions:
which branching model have you used in ur project?
******************************
Strong experience in Microservices (Decompose, Strangler, Saga, Event sourcing, CQRS, Tx Messaging). Knowledge of a microservices architecture.
**************************************************
The 12-Factor Principles
Codebase (One codebase tracked in revision control, many deploys)
Dependencies (Explicitly declare and isolate the dependencies)
Config (Store configurations in an environment)
Backing Services (treat backing resources as attached resources)
Build, release, and Run (Strictly separate build and run stages)
Processes (execute the app as one or more stateless processes)
Port Binding (Export services via port binding)
Concurrency (Scale out via the process model)
Disposability (maximize the robustness with fast startup and graceful shutdown)
Dev/prod parity (Keep development, staging, and production as similar as possible)
Logs (Treat logs as event streams)
Admin processes (Run admin/management tasks as one-off processes)