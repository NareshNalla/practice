# Core Java Interview Notes

## 1. Java Core Concepts

### Immutability
- **Class:** Should be declared `final` to prevent extension.
- **Fields:** All fields should be `private` and `final`.
- **Mutable Fields:** If a field is a mutable object (like a `Date` or a `List`), you must perform a deep copy.
    - In the constructor, create new copies of the incoming mutable objects.
    - In the getter, return a new copy of the internal mutable object, not a reference to it. This is called "defensive copying".
- **Why `final` class?** Prevents subclasses from altering the immutable behavior.

### OOP (Object-Oriented Programming)
- **Composition:** A "has-a" relationship. Achieved by using instance variables that refer to other objects. The composed object often cannot exist without the other entity (e.g., a `Book` in a `Library`).
- **Inheritance:**
    - **Upcasting:** Casting a child object to a parent object (`Parent p = new Child();`). This is implicit and safe.
    - **Downcasting:** Casting a parent reference back to a child object (`Child c = (Child)p;`). This is explicit and can throw a `ClassCastException` if the object is not actually of the child type.
    - **Method Hiding:** `static` methods are hidden, not overridden. The method called depends on the reference type, not the object type.
- **Cohesion & Coupling:**
    - **Cohesion:** Refers to how focused a single class/module is. **High cohesion** is good; the class does one thing well.
    - **Coupling:** Refers to how dependent two classes are on each other. **Low coupling** is good; changes in one class don't require changes in another.

### Generics
- **Purpose:** Provide compile-time type safety.
- **Type Erasure:** The compiler removes generic type information after compilation. It replaces generic parameters with their bounds (or `Object`) and adds necessary casts. This ensures no new classes are created at runtime, avoiding overhead.

### Serialization & Externalization
- **Serialization:** The process of converting an object's state into a byte stream. The `Serializable` marker interface is used.
    - `serialVersionUID`: A version number for a class to ensure that a serialized object can be deserialized correctly, even if the class has changed.
    - `transient`: Keyword used to mark fields that should not be serialized.
    - **Deserialization Constructor:** No constructor is called during standard deserialization.
- **Externalization:** A way to have custom control over the serialization process.
    - Requires implementing the `Externalizable` interface (which extends `Serializable`).
    - You must implement `writeExternal(ObjectOutput out)` and `readExternal(ObjectInput in)`.
    - **Constructor:** The public no-argument constructor **is called** during deserialization before `readExternal` is invoked.

---

## 2. Collections Framework

### General Concepts
- **`hashCode()` and `equals()` Contract:**
    1. If two objects are equal according to `equals()`, they MUST have the same hash code.
    2. If two objects have the same hash code, they are NOT required to be equal. (This is a hash collision).
- **Iterators:**
    - **Fail-Fast:** Throws a `ConcurrentModificationException` if the collection is modified while being iterated over (e.g., `ArrayList`, `HashMap`).
    - **Fail-Safe:** Works on a copy of the collection, so it doesn't throw an exception if the original collection is modified (e.g., `ConcurrentHashMap`).

### `HashMap` and Relatives
- **`HashMap`:**
    - Unsynchronized.
    - Allows one `null` key and multiple `null` values.
    - **Java 8+ Improvements:** If a bucket has too many entries (more than `TREEIFY_THRESHOLD`), the linked list is converted into a self-balancing binary search tree (`TreeNode`), improving performance from O(n) to O(log n) for worst-case lookups.
    - **`keySet()` vs. `entrySet()`:** Iterating over `entrySet()` is generally more efficient because it gives you both the key and value directly. `keySet()` requires an additional lookup (`get(key)`) for each value.
- **`ConcurrentHashMap`:**
    - Thread-safe without locking the entire map.
    - Uses "lock striping" (dividing the map into segments/buckets and locking only the relevant one).
    - Provides a fail-safe iterator.
- **`Hashtable`:**
    - Legacy class.
    - Fully synchronized (locks the entire map for any operation), leading to poor concurrency.
    - Does not allow `null` keys or values.
    - `Collections.synchronizedMap(new HashMap<>())` is a modern way to get a fully synchronized map, but it also has a fail-fast iterator.
- **`LinkedHashMap`:**
    - Subclass of `HashMap`.
    - Maintains the insertion order of elements.
- **`TreeMap`:**
    - Stores keys in sorted order (natural order or by a provided `Comparator`).
    - Implemented as a Red-Black tree. Insertion and lookup time is O(log n).

### Other Collections
- **`WeakHashMap`:**
    - Holds keys as "weak references".
    - If a key is no longer referenced anywhere else, it is eligible for garbage collection. This is useful for caching.
- **`IdentityHashMap`:**
    - Compares keys using reference equality (`==`) instead of object equality (`equals()`).
- **`ArrayList`:**
    - When an `ArrayList` is filled, it creates a new, larger array and copies the elements over. This is a **shallow copy**.

---

## 3. Concurrency and Multithreading

### Core Concepts
- **`yield()`:** A hint to the thread scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.
- **`join()`:** Pauses the execution of the current thread until the thread it is joining with completes its execution.

### Deadlocks
- **How to avoid:**
    1.  **Avoid Nested Locks:** A thread should not hold multiple locks at once.
    2.  **Lock Ordering:** If multiple locks are needed, ensure every thread acquires them in the same fixed order.
    3.  **Use `tryLock` with a Timeout:** Acquire a lock with a timeout (`lock.tryLock(timeout, unit)`) to avoid waiting indefinitely.
    4.  **Avoid Unnecessary Locks:** Don't lock code that doesn't need to be thread-safe.

### Exception Handling in Threads
- A `try-catch` block in a parent thread **cannot** catch an exception thrown in a child thread.
- Use `Thread.UncaughtExceptionHandler` to handle exceptions that propagate out of a thread.

---

## 4. JVM and Memory

### Java Memory Model
- **Heap Memory:** Where Java objects are stored. Divided into generations for GC.
    - `-Xms`: Initial heap size.
    - `-Xmx`: Maximum heap size.
- **Metaspace:** (Since Java 8) Replaced the old PermGen space. Stores class metadata. It is part of native memory and auto-grows by default.
- **Stack Memory:** Each thread has its own stack. Stores local variables, method call information, and partial results.
- **Codecache:** Used by the Just-In-Time (JIT) compiler to store compiled native code.

### Garbage Collection (GC)
- **Process:** Marking (find live objects), Deletion (remove dead ones), and optional Compaction (move live objects together).
- **Generational GC:**
    - **Young Generation:** Where new objects are created (in the "Eden" space). Minor GCs happen here. Survivors move to Survivor spaces (S0, S1).
    - **Old (Tenured) Generation:** Objects that survive multiple GC cycles in the Young Gen get "promoted" here. Major GCs happen here.
- **GC Algorithms:**
    - **Serial:** Single-threaded. Freezes the application (Stop-The-World, STW).
    - **Parallel:** Uses multiple threads for GC but is still STW.
    - **CMS (Concurrent Mark Sweep):** Tries to do most of the work concurrently with the application to minimize pause times. Can have fragmentation issues.
    - **G1 (Garbage-First):** Divides the heap into regions. Aims for more predictable pause times. Default in modern Java.
    - **Shenandoah / ZGC:** Newer collectors focused on ultra-low pause times.

### Class Loader
- **Responsibility:** Loads class files into memory.
- **Types:**
    1.  **Bootstrap Class Loader:** Loads core Java APIs (from `rt.jar`).
    2.  **Platform Class Loader:** (Java 9+) Loads platform classes.
    3.  **System/Application Class Loader:** Loads classes from the application classpath.
- **Steps:**
    1.  **Loading:** Finds the `.class` file and creates a `Class` object.
    2.  **Linking:** Verification, Preparation (allocating memory for static variables), and Resolution.
    3.  **Initialization:** Executes static initializers and assigns initial values to static variables.

---

## 5. Java 8+ Features

### Functional Programming
- **Functional Interface:** An interface with exactly one abstract method (e.g., `Runnable`, `Callable`).
    - `@FunctionalInterface` annotation is optional but recommended.
    - **`Predicate<T>`:** `boolean test(T t)`
    - **`Function<T, R>`:** `R apply(T t)`
    - **`BinaryOperator<T>`:** `T apply(T t1, T t2)`
- **Lambda Expressions:** A concise way to implement an instance of a functional interface.
- **Default and Static Methods:** Interfaces can now have methods with implementations.

### `Optional`
- A container object which may or may not contain a non-null value.
- **Purpose:** To avoid `NullPointerException` and create more expressive, readable APIs.

### `StringJoiner`
- Used to construct a sequence of strings separated by a delimiter, with an optional prefix and suffix.

### New `Map` Methods
- `computeIfAbsent()`: Computes a value if the key is not present.
- `computeIfPresent()`: Computes a new value if the key is present.
- `getOrDefault()`: Returns a default value if the key is not found.
- `merge()`: Combines a new value with an existing one.

---

## 6. Exceptions

- **`throws` vs. `try-catch`:**
    - `throws` delegates the responsibility of handling a **checked exception** to the calling method. It does not handle the exception itself.
    - `try-catch` actually handles the exception. It is generally recommended over `throws` to prevent abnormal program termination.
- **Custom Exceptions:**
    - **Checked:** Extend `java.lang.Exception`.
    - **Unchecked:** Extend `java.lang.RuntimeException`.

---

## 7. Miscellaneous

### Code Obfuscation
- **Purpose:** To make reverse-engineering of Java bytecode more difficult.
- **Techniques:** Renaming (methods/variables), control flow obfuscation, string encryption, etc.
- **Tool:** **ProGuard** is a popular tool for shrinking, optimizing, and obfuscating Java code.

### `String.substring()`
- In older Java versions (before 7u6), `substring()` would hold a reference to the original, complete character array, which could cause memory leaks. This is no longer the case; it now creates a new array.

### Spring Actuator
- Provides production-ready features for monitoring and managing a Spring Boot application.
- **Endpoints:**
    - `/health`: Shows application health information.
    - `/info`: Displays arbitrary application info.
    - `/metrics`: Shows various application metrics.
    - `/loggers`: View and modify application log levels.
